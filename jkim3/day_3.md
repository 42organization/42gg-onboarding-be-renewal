# 42gg 온보딩
    
- 3일차
    1. @Embedded, @Embeddable
        
        → 새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서는 이것을 임베디드 타입(embedded type)이라 합니다.
        
        @Embedded : 값 타입을 사용하는 곳에 표시
        
        @Embeddable :  값 타입을 정의하는 곳에 표시
        
        **임베디드 타입(컴포넌트)은 기본 생성자가 필수이다.
        
    2. 연관 관계 설정
        
        → 예시
        
        주문시스템
        
        - @OneToOne 주문과 배달 = 1 : 1
        - @ManyToOne 주문과 회원 = N : 1
        - @ManyToMany 주문과 상품, 상품과 카테고리 = N : M
        - @OneToMany 회원과 주문 = 1 : N
        
        → @ManyToMany의 단점
        
        - 다대다 관계의 경우 그대로 사용하지 못하고 반드시 정규화를 통해 중간 테이블을 만들어줘야 한다. 이러한 관계가 있을 때 반드시 중간 중간 테이블을 두어 일대다+다대일 형태로 변형해줘야 한다.
        - JPA에서는 @ManyToMany를 통해 연관관계를 매핑할 경우 하이버네이트가 위와 같은 중간 테이블을 알아서 만들어서 처리해준다.
        - 하이버네이트에 의해 생성된 중간 테이블은 관계 설정에 필수적으로 필요한 정보들만 담겨있을 뿐 이러한 비즈니스 로직상 필요한 정보들은 담기지 않는다.
        
        → 중간 테이블
        
        - 일대다와 다대일 같은 경우 서로 관계를 맺기 위해 한 쪽 테이블에서 하나의 외래키를 가져 연관 관계를 관리한다.
        
        → 연관관계의 주인
        
        - 테이블에서는 다(N)쪽에서 외래키를 관리하고 JPA에서도 다(N)쪽에서 관리하는 것을 지향한다.
        - 엄밀히 이야기하면 객체에는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
        - 반면에 데이터베이스 테이블은 외래 키 하나로 양쪽이 서로 조인할 수 있다. 따라서 **테이블은 외래 키 하나만으로 양방향 연관관계를 맺는다.**
        - 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제)할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.
        - 어떤 연관관계를 주인으로 정할지는 `mappedBy` 속성을 사용하면 됩니다.
        - 주인은 `mappedBy` 속성을 사용하지 않는다.
        - 주인이 아니면  `mappedBy` 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 한다.
        - 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것.
        
        → PK
        
        후보 키 중 하나를 기본 키로 선택할 수 있다. 데이터베이스는 각 데이터를 고유하게 식별하는 용도로 기본 키를 사용한다. 
        
        → FK
        
        다른 테이블에 있는 기본 키를 참조해서 사용할 때, 외래 키라고 부른다.
