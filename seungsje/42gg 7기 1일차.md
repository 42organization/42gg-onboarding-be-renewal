# 42gg 7기 1회차

- HTTP METHOD [https://inpa.tistory.com/entry/WEB-🌐-HTTP-메서드-종류-통신-과정-💯-총정리](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
    - 클라이언트와 서버사이에 이루어지는 요청(request) 응답(response) 데이터를 전송하는 방식
    
    서버가 수행해야할 동작을 지정하는 요청을 보내는 방법
    
    - GET
        
        리소스 조회 메소드 (Read)
        
        전달하는 데이터는 쿼리스트링을 통해서 전달
        
        쿼리스트링이란? url 주소뒤에 덧붙여서 정보를 서버측에 전달하는 방법
        
        주소/리소스경로?파라미터=값&파라미터=값
        
        ?뒤가 쿼리파라미터이며, =으로 key와 value가 구분된다.
        
        정적 데이터 조회
        
        이미지나 정적 텍스트 문서를 GET하면
        
        쿼리 파라미터없이 리소스 경로로 단순하게 조회 가능하다.
        
        /member/100으로 100번 멤버를 조회해서 정보를 달라고 GET요청
        
        서버에서는 100번 멤버를 조회해서 응답(Responce)을 만들어서 보냄
        
        클라이언트가 정상적으로 받으면 200 OK status를 가지고, 정보를 얻게 됨.
        
        동적 데이터 조회
        
        주로 검색, 게시판 목록에서 검색어로 이용
        
        쿼리 파라미터를 사용해서 데이터를 전달
        
        쿼리 파라미터를 기반으로 정렬 필터해서 결과를 동적으로 생성한다.
        
    - POST
        
        전달한 데이터 처리/생성 요청 메소드(create)
        
        메시지 바디(body)를 통해 서버로 요청 데이터를 전달하면 서버는 요청 데이터를 처리하여 업데이트
        
        전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
        
        만일 데이터를  GET하는데 있어서 JSON으로 조회 데이터를 넘겨야 하는 애매한 경우 사용한다.
        
        JSON이란? 자바스크립트 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷
        
        클라이언트는 body에 등록할 회원 정보를 JSON 형태로 만들어서 서버로 전송
        
        서버에서는 받은 메세지를 분석해 로직대로 처리 -ex) 데이터베이스에 등록하고 신규 아이디를 생성
        
        신규 데이터를 바디에 담아서 클라이언트로 응답
        
        200이나 201의 성공응답
        
        Location은 새로운 데이터의 URI (식별자가 있는 URL(포함개념)) 경로이다.
        
    - PUT
        
        리소스를 대체(수정)하는 메소드(update)
        
        요청 메세지에 리소스가 있으면 덮어쓰고 없으면 새로 생성
        
        구체적인 전체 경로를 지정해서 보내주어야 한다.
        
        부분만 고치는건 안됨(걍 덮어 써버림)
        
    - PATCH
        
        리소스 일부 부분을 변경하는 메소드(update)
        
        패치를 지원하지 않는 경우 POST를 씀
        
    - DELETE
        
        리소스를 제거하는 메소드(Delete)
        
        상태코드는 대부분 200인데 상황에따라 204
        
    - HEAD
        
        GET과 동일하지만 서버에서 Body를 리턴하지 않음
        
        응답의 상태코드만 확인할때처럼 리소스을 받지 않고 오직 찾기만 원할때 사용(검사 용도)
        
        서버의 응답 헤더를 봄으로써 리소스가 수정 되었는지 확인할 수 있다.
        
    - OPTIONS
        
        예비 요청(preflight)에 사용되는 HTTP 메소드
        
        본 요청을 하기 전에 안전한지 미리 검사하는 것
        
        서버의 지원 가능한 HTTP메서드와 출처를 응답받아 CORS 정책을 검사하기 위한 요청
        
        CORS 정책이란?
        
        브라우저가 요청 헤더에 Origin이라는 필드에 출처를 함께 담아 보내는데, 이후 서버가 응답할 때 응답 헤더에 Access-Control-Allow-Origin이라는 필드에 값으로 리소스접근이 허용된 출처 url을 보낸다.
        
        클라이언트에서 Origin과 서버에서 보낸 Access-Control-Allow-Origin을 비교한다.
        
    - CONNECT
        
        요청한 리소스에 대해 양방향 연결을 시작하는 메소드
        
        SSL(HTTPS)를 사용하는 웹 사이트를 접속하는데 사용한다.
        
        클라이언트는 원하는 목적지와 TCP연결을 HTTP 프록시 서버에 요청한다.
        
        서버는 클라이언트 대신하여 연결의 생성을 진행한다.
        
        한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고가는 TCP 스트림을 계속해서 프록시한다.
        
    - TRACE
        
        검사용
        
        서버에 도달 했을때 최종 패킷의 요청 패킷 내용을 응답 받는다.
        
        요청의 최종 수신자는 반드시 송신자에게 200(OK) 응답의 내용(Body)로 수신한 내용을 반송한다.
        
        최초 클라이언트의 요청에는 Body가 포함될 수 없다.
        
        방화벽이나 프록시서버, Gateway를 거치면서 패킷내용이 바뀌는지 확인하는 것
        
- HTTP Status Code [https://hongong.hanbit.co.kr/http-상태-코드-표-1xx-5xx-전체-요약-정리/](https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/)

1XX: Informational(정보 제공)

임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미

2XX: Success(성공)

클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미

3XX: Redirection(리다이렉션)

완전한 처리를 위해서 추가 동작이 필요한 경우.
주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미

4XX: Client Error(클라이언트 에러)

없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미

5XX: Server Error(서버 에러)

서버 사정으로 메시지 처리에 문제가 발생한 경우. 

서버의 부하, DB 처리 과정 오류, 서버에서 익셉션(Exception)이 발생하는 경우를 의미.

익셉션이란? 프로그래밍에서 발생하는 오류

익셉션을 처리하지 않을경우 프로그램이 중단되거나 예기치 않은 동작을 한다.

따라서 이를 대응하는 코드가 ‘익셉션 핸들링’

익셉션은 크게 두가지로 나뉜다.

1. 체크 예외(Checked Exception): 컴파일러가 체크하는 예외, 이런 예외가 발생할 수 있는 코드에는 반드시 예외 처리 코드를 추가해야 합니다. 예를 들어, 파일 입출력(IOException)이 이에 해당
2. 언체크 예외(Unchecked Exception): 실행 시(Runtime)에만 발생할 수 있는 예외, 실수로 인해 발생. 예를 들어, 배열의 범위를 벗어나는 경우(IndexOutOfBoundsException) 등이 이에 해당
- HTTP 헤더 [https://gmlwjd9405.github.io/2019/01/28/http-header-types.html](https://gmlwjd9405.github.io/2019/01/28/http-header-types.html)
    - [General header](https://developer.mozilla.org/ko/docs/Glossary/General_header): 요청과 응답 모두에 적용되지만 바디에서 최종적으로 전송되는 데이터와는 관련이 없는 헤더.
    - [Request header](https://developer.mozilla.org/ko/docs/Glossary/Request_header): 패치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더.
    - [Response header](https://developer.mozilla.org/ko/docs/Glossary/Response_header): 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더.
    - [Entity header](https://developer.mozilla.org/ko/docs/Glossary/Entity_header): 컨텐츠 길이나 MIME 타입과 같이 엔티티 바디에 대한 자세한 정보를 포함하는 헤더.
- 크롬 개발자도구 (Network, Application 위주로) [https://velog.io/@remon/개발자-도구의-기능을-뜯어보자](https://velog.io/@remon/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC%EC%9D%98-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%9C%AF%EC%96%B4%EB%B3%B4%EC%9E%90)
- REST API 란 무엇인가?
    - REST란?
        
        Representational State Transfer의 약자로 자원을 이름으로 구분하여 자원의 상태를 주고받는 모든 것을 의미.
        
        1. HTTP URI(Uniform resource identifier)을 통해 자원(resource)을 명시
        2. HTTP Method(POST, GET, PUT, DELETE, PATCH 등)을 통해
        3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미
        
        CRUD Operation이란
        
        생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)를 묶어서 일컫는 말
        
        Create : 데이터 생성(POST)
        
        Read : 데이터 조회(GET)
        
        Update : 데이터 수정(PUT, PATCH)
        
        Delete : 데이터 삭제(DELETE)
        
    - REST의 구성 요소
        1. 자원(Resource) : HTTP URI
        2. 자원에 대한 행위(Verb) : HTTP Method
        3. 자원에 대한 행위의 내용 (Representations) : HTTP Message Pay Load
    - REST의 특징
        1. Server-Client(서버-클라이언트 구조)
            
            자원이 있는쪽이 Server, 요청하는쪽이 Client
            
            REST Server : API를 제공하고 비즈니스 로직 처리 및 저장
            
            Client : 인증이나 context(세션, 로그인정보) 등을 관리
            
            서로 간 의존성이 줄어든다.
            
        2. Stateless(무상태)
            
            Client의 context를 서버에 저장하지 않음
            
            세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 됨으로써 구현이 쉬움
            
            서버는 각각의 요청을 별개의 것으로 인식하고 처리
            
            각 API 서버는 Client의 요청만을 처리
            
            이전 요청이 다음 요청의 처리에 연관되어서는 안됨
            
            이전 요청이 DB수정을 해서 DB에 의해 바뀌는 것은 허용
            
            서버의 처리 방식에 일관성을 부여하고 부담이 줄어들며 서비스의 자유도가 높아짐
            
        3. Cacheable(캐시 처리 가능)
            
            웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용 가능 하기 때문에, 캐싱 기능을 적용할 수 있다.
            
            HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.
            
            대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.
            
            캐시 사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다.
            
        4. Layered System(계층화)
            
            REST Server는 다중 계층으로 구성될 수 있다.
            
            API Server는 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다.
            
            로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.
            
            PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.
            
        5. Uniform Interface(인터페이스 일관성)
            
            URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
            
            HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
            
            특정 언어나 기술에 종속되지 않는다.
            
    - REST의 장단점
        - 장점
            - HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
            - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해 준다.
            - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
            - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
            - REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
            - 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
            - 서버와 클라이언트의 역할을 명확하게 분리한다.
        - 단점
            - 표준이 자체가 존재하지 않아 정의가 필요하다.
            - HTTP Method 형태가 제한적이다.
            - 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 정보의 값을 처리해야 하므로 전문성이 요구된다.
            - 구형 브라우저에서 호환이 되지 않아 지원해주지 못하는 동작이 많다.(익스플로어)
    - REST API란?
        
        API(Application programming interface)란?
        
        데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능하도록 하는 것
        
        ex) 기상청의 소프트웨어 시스템에 있는 기상 데이터를 휴대폰의 날씨 앱이 API를 통해 휴대폰에 날씨 정보를 표시함.
        
        REST API란?
        
        REST 기반으로 서비스 API를 구현한 것
        
        최근 OpenAPI(누구나 사용할 수 있도록 공개된 API)의 대부분은 REST API를 제공한다.
        
        REST API의 특징
        
        사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
        
        REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
        
        즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.
        
    - RESTful이란?
        
        REST API를 제공하는 웹 서비스를 RESTful하다 라고 한다.
        
        REST 원리를 따르는 시스템을 RESTful 하다고 하며, 따로 정의된 것은 아니다.
        
        RESTful의 목적
        
        이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
        
        RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다.
        
        RESTful 하지 못한 경우
        
        ex1) CRUD 기능을 모두 POST로만 처리하는 API
        
        ex2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)
        
- 쿠키와 세션, JWT토큰
    - 쿠키
        
        클라이언트에 저장될 목적으로 생성한 작은 정보를 담은 파일(서버에서 사용자 브라우저로 전송)
        
        브라우저는 서버에서 받은 쿠키를 저장해두었다가, 동일한 서버로 재요청할 때 쿠키를 함께 전송
        
        사용자가 로그인 하면 서버는 ID, PW 정보를 쿠키에 담아 브라우저로 보낸다. 브라우저에서는 요청할 때마다 로그인 정보가 담긴 쿠키를 함께 보내면, 브라우저에서 매번 요청할 때마다 서버는 로그인 정보가 담긴 쿠키를 받는다.
        
        장점
        
        기존 로그인 정보를 사용하기 때문에 인증을 위한 추가적인 데이터 저장이 필요 X
        
        단점
        
        정보를 매번 요청에 담기 때문에 보안의 위험
        
        클라이언트에서 쿠키 정보를 쉽게 변경, 삭제, 가로채기 가능
        
        쿠키 사이즈가 커질수록 네트워크 부하가 심해짐
        
        쿠키의 구성요소
        
        - Name(이름) : 쿠키를 구별하는 데 사용되는 키(중복 불가)
        - Value(값) : 쿠키의 값
        - Domain(도메인) : 쿠키가 저장된 도메인
        - Path(경로) : 쿠키가 사용되는 경로
        - Expires(만료기한) : 쿠키의 만료기한
    - 세션
        
        서버에서 일정시간동안 클라이언트 상태를 유지하기 위해 사용한다.
        
        서버에서 클라이언트별로 유일한 세션 ID를 부여하고, 세션 정보를 서버에 저장한다.
        
        세션 ID : 사용자의 주요 정보가 아닌 사용자를 식별할 수 있는 값 → 보안때문에
        
        서버에서 생성한 세션 ID는 클라이언트의 쿠키 값(세션 쿠키)으로 저장되고, 클라이언트 요청을 보낼 때 세션 쿠키를 함께 보낸다. 
        
        서버에서는 클라이언트별 세션 쿠키 값이 저장되어있으므로, 요청으로 온 세션 쿠키값을 보고 어떤 클라이언트인지 식별한다.
        
        장점
        
        사용자의 로그인 정보를 주고 받지 않기 때문에 상대적으로 안전하다.
        
        사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원DB를 찾지 않아도 된다.
        
        단점
        
        사용자를 식별할 수 있는 값인 세션 ID를 생성하고, 서버에 저장해야하는 작업이 생긴다.
        
        서버 세션 저장소를 사용하므로 요청이 많아지면 서버 부하가 심해진다.
        
    - JWT토큰(JSON Web Token)
        
        JWT : 인증에 필요한 정보들을 암호화시킨 토큰
        
        JWT 토큰(Access Token)을 HTTP 헤더에 담아 서버가 클라이언트를 식별한다.
        
        JWT 구조
        
        Header
        
        토큰 타입, 해쉬 알고리즘(HS256 or RSA 등)으로 구성되어 있다.
        
        ```jsx
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
        
        Payload
        
        claim이  포함되는 영역으로, 토큰에 담을 정보를 가지고 있다.
        
        claim : key - value 형식으로 이루어진 한 쌍의 정보로, 엔티티(주로 사용자)에 대한 속성을 설명한다.
        
        클라이언트 고유 ID 값이나 유효 기간 등이 포함되는 영역이다.
        
        ```jsx
        {
          "sub": "1234567890",
          "username": "user1",
          "admin": true
        }
        ```
        
        Signature
        
        인코딩된 Header와 Payload를 더한 뒤, secret key로 해싱해서 생성한다. 이때 해싱 방법은 Header에서 지정한 해쉬 알고리즘으로 한다.
        
        Header와 Payload는 단순히 인코딩된 값이라서 누구나 복호화가 가능하나, Signature는 서버 측에서 관리하는 secret key가 있어야 복호화가 가능하다.
        
        Signature 부분으로 토큰의 위변조 여부를 확인할 수 있다.
        
        ```jsx
        HMACSHA256(
          base64UrlEncode(header) + "." +
          base64UrlEncode(payload),
          secret)
        ```
        
        JWT의 작동
        
        ![Untitled](cookie.png)
        
        1. 클라이언트가 ID, PW 로그인 요청을 보낸다.
        2. 회원 DB에서 사용자를 확인한다.
        3. 로그인 성공 시, 서버는 로그인 정보를 Payload에 담고, Secret Key를 사용해서 Access Token(JWT)을 발급한다.
        4. 서버가 JWT를 Client에 전달한다. 이 때 전달방법은 개발자가 정한다.
            
            ex) 응답 Header에 `Authorization: BEARER <JWT>` 형태로 전달
            
        5. 클라이언트는 전달받은 토큰(JWT)을 저장한다.(쿠키, local storage 등)
        6. 클라이언트가 서버에 요청할 때마다 토큰(JWT)을 요청 Header의 `Authorization` 에 포함시켜 함께 전달한다.
        7. 서버는 클라이언트가 전달한 토큰의 Signature를 secret Key로 복호화한 후, 위변조 여부 및 유효기간을 검증한다.
        8. 검증에 성공하면, JWT에서 사용자 정보를 확인하고 요청에 응답한다.
        
        장점
        
        동시 접속자가 많을 때 서버 부하를 낮춘다.
        
        클라이언트, 서버가 다른 도메인을 사용할 때 사용 가능하다.
        
        ex) 카카오 OAuth2 로그인 시 JWT 토큰 사용
        
        인증 정보를 서버에 별도로 저장할 필요가 없다. → 서버의 Stateless 특성이 유지된다.
        
        단점
        
        구현 복잡도가 증가한다.
        
        JWT에 담는 내용이 커질수록 네트워크 비용이 증가한다.
        
        이미 생성된 JWT를 일부만 만료시킬 방법이 없다. (토큰의 유효기간을 너무 길게 잡으면 안된다.)
        
        Secret Key 유출 시 JWT 조작이 가능하다.
        
        Payload 자체는 암호화되지 않기 때문에 사용자의 중요한 정보는 담을 수 없다.
        
- MVC, MVC2, spring MVC, Front Controller Model
    
    Model View Controller
    
    Model
    
    웹 애플리케이션이 클라이언트의 요청을 전달받으면 요청 사항을 처리하기 위한 작업을 한다.
    
    처리한 작업의 결과 데이터를 클라이언트에게 응답을 돌려주어야 하는데, 이때 클라이언트에게 응답으로 돌려주는 작업의 처리 결과 데이터를 Model이라 한다.
    
    클라이언트의 요청 사항을 구체적으로 처리하는 영역을 서비스 계층(Service layer)라고 하며, 요청 사항을 처리하기 위해 Java 코드로 구현한 것을 비즈니스 로직(Business Logic)이라 한다
    
    View
    
    View(뷰)는 Model을 이용하여 웹 브라우저와 같은 애플리케이션의 화면에 보이는 리소스(Resource)를 제공하는 역할을 한다.
    
    Controller
    
    컨트롤러는 클라이언트 측의 요청을 직접적으로 전달받는 엔드포인트(Endpoint)로써 Model과 View의 중간에서 상호작용을 해주는 역할을 한다.
    
    클라이언트 측의 요청을 전달받아 비즈니스 로직을 거친 후, Model 데이터가 만들어지면, 이 Model 데이터를 View로 전달하는 역할을 한다.
    
    이렇게 세가지 요소로 나누어진 패턴을 MVC패턴이라고 한다.
    
    MVC1
    
    View와 Controller를 모두 JSP가 담당하는 형태. JSP하나로 유저의 요청을 받고 응답을 처리하므로 구현 난이도가 쉽다.
    
    JSP하나에서 MVC가 모두 이루어지므로 재사용성도 떨어지고 읽기도 힘듬(유지보수 힘듬)
    
    MVC2
    
    요청을 컨트롤러(Servlet)이 먼저 받는다. Controller, View가 분리되어있어서 수정할때 쉽고 유지보수에도 이점이 있다.
    
    spring MVC
    
    ![Untitled](mvc2.png)
    
    FrontController에 컨트롤러(핸들러)에서 mapping을 어노테이션이 알려주면, 핸들러 어댑터 목록에 추가되고 프론트 컨트롤러가 모든 요청을 받아서 실제로 있는(컨트롤 목록에 있을 시) 컨트롤러로 보내주고, 아닐경우 익셉션으로 반환
    
- 인프라
    - IT환경을 운영하고 관리하는데 필요한 구성요소
        
        하드웨어, 소프트웨어, 네트워킹 구성 요소, 운영 체제, 데이터 스토리지 등이 있음
        
        하드웨어
        
        서버, 데이터센터, 개인컴퓨터, 라우터, 스위치, 기타 장비를 포함
        
        데이터 센터를 보관하고 냉각하고 동력을 공급하는 시설도 인프라로 간주할 수 있다.
        
        소프트웨어
        
        웹 서버, 콘텐츠 관리 시스템, 리눅스와 같이 OS 등 기업에서 사용하는 애플리케이션을 의미
        
        OS는 시스템 리소스 및 하드웨어를 관리하며, 애플리케이션과 하드웨어 사이에서 모든 소프트웨어와 작업을 수행하는 물리적 리소스를 연결한다.
        
        네트워킹
        
        인터넷 연결, 네트워크 활성화, 방화벽 보안을 비롯해 라우터, 스위치, 케이블 같은 하드웨어로 구성
        
        IT 인프라 유형
        
        On - Premise
        
        기업이 자체 데이터센터를 보유하고, 그 안에 서버와 네트워크 장비 등을 구축하고 자체적으로 운영하는 방식
        
        클라우드 컴퓨팅 방식이 나오기 전까지 일반적으로 사용되는 방식이었으며, 기억이 직접 구축한 Private Cloud도 On-Premise 환경에 속한다.
        
        데이터 센터의 관리(항온항습기, 전력시스템 등)부터 물리시스템 구축 및 운영까지 관리 coverage가 넓다.
        
        직접관리할 수 있어서 보안에 이점이 있으나, 장비를 직접 사서 관리해야하기 때문에 초기비용이 많이 든다.
        
        Public Cloud
        
        인프라는 Cloud Service Provider(CSP)에서 구축하고 운영 및 관리를 한다.
        
        어느 기업이든 클라우드 이용을 원한다면 CSP에서 제공하는 콘솔을 통해 필요한 리소르를 바로 생성하고 이용할 수 있다.
        
        데이터 센터를 직접 운영하거나 관리할 필요가 없기 때문에, 운영하는 서비스에서만 집중할 수 있다.
        
        초기 투자금이 적기때문에 많은 기업들이 클라우드 기반으로 바꾸는 추세
        
        - HTTPS
            
            웹 브라우저와 웹 서버 간에 안전하게 데이터를 전송하기 위한 프로토콜
            
            HTTPS는 HTTP의 보안 버전으로, SSL/TLS(보안 소켓 계층/전송 계층 보안) 프로토콜을 사용하여 데이터를 암호화해서 전송 중인 데이터가 중간에서 도청되거나 변조되지 않도록 보호함.
            
        - DNS 서버
            - 도메인 이름을 IP 주소로 변환하는 역할
            - 도메인 이름을 입력하면 해당 도메인 이름에 연결된 IP 주소를 반환하여 웹사이트에 접속할 수 있도록 도와주고 캐싱을 통해 다음에 접속할 땐 빠르게 접속할 수 있도록 도와준다.
        - CI/CD
            - CI(Continuous Integration)
                
                개발할때 작은 단위로 코드를 업로드하면, 자동으로 빌드, 테스트를 통해 코드에 문제가 있는지 알아내는 것
                
            - CD(Continuous Deployment/Delivery)
                
                배포를 자동화한다. 수동으로 할수도 있음.