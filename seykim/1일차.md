# 온보딩 1~2일차
- [HTTP METHOD](#http-method)
- [HTTP STATUS](#http-status)
- [HTTP HEADER](#http-header)
- [REST API](#rest-api)
- [Cookie & Session](#cookie--session)
- [JWT](#jwt)
- [MVC && MVC2](#mvc--mvc2)
- [HTTPS & DNS Server & CI/CD](#https--dns-server--cicd)

## [HTTP METHOD](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)

- 클라이언트 <-> 서버 간의 통신에서 이루어지는 요청(Request)과 응답(Response)에서 데이터를 전송하는 방식
- 주어진 리소스에 수행하길 원하는 행동

### 총 사용되는 메소드 9개

|주요 메소드|설명|
|:--|:--|
|[GET](#주요-메소드---get)|리소스 조회|
|[POST](#주요-메소드---post)|요청 데이터 처리, 주로 등록으로 사용|
|[PUT](#주요-메소드---put)|리소스 덮어쓰기, 해당 리소스가 없으면 생성|
|[PATCH](#주요-메소드---patch)|리소스 부분 덮어쓰기(특정부분 update)|
|[DELETE](#주요-메소드---delete)|리소스 삭제|
-----------------
|기타 메소드|설명|
|:--|:--|
|[HEAD](#기타-메소드---head)|GET과 동일하지만 메시지 부분(body)을 제외하고 상태줄과 헤더만 반환|
|[OPTIONS](#기타-메소드---options)|대상 리소스에 대한 통신 기능 옵션(메소드)을 설명|
|[CONNECT](#기타-메소드---connect)|대상 자원으로 식별되는 서버에 대한 터널을 설정|
|[TRACE](#기타-메소드---trace)|대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행|
-------

- ##### 주요 메소드 - GET

		리소스 조회 메소드(READ)
		전달하고 싶은 데이터는 쿼리스트링을 통해서 전달
		- 예시 : GET /sample/100?name=test&age=20

		쿼리스트링 대신 메시지 바디를 통해서 전달할 수 있지만, RESTful한 방법이 아니고 서버에서 따로 구성해야하기  때문에 권장하지 않음

		조회할 때 POST도 사용할 수 있지만, GET 메소드는 캐싱이 가능해서 조회에서는 GET 메소드가 유리함

	- ###### 정적 데이터 조회과정
		1. 이미지 또는 정적 텍스트 문서 GET
		2. 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능
		- 예시 :  GET /sample/100 HTTP1.1 -> 100번째 데이터를 단순 조회하는것
	- ##### 동적 데이터 조회과정
		1. 주로 검색, 게시판 목록에서 검색어로 이용
		2. 쿼리 파라미터를 사용해서 데이터 전달
		3. 쿼리 파라미터는 key=valeu&key=value 의 구조로 되어있음
		- 예시 : GET /search/name=hello&age=20 -> 조건에 부합한 상세 데이터를 찾아서 조회해줌
	- ##### HTML Form 데이터 조회과정
		1. 웹 문서에서 폼 입력칸에 데이터를 적고 전송 버튼을 누름  
		2. 지정한 GET 메소드 동작에 따라 해당 태그안에 들어간 값들이 쿼리스트링으로 서버로 전송됨
		- 예시 : input안에 name과 age를 입력하게 되어있다면 이것이 GET /search/name=hello&age=20 이런식으로 서버로 전송이 됨
		- HTML Form 태그 문서로 사용자와 UI로 상호작용하여 서보와 통신
		- HTML Form 전송은 GET, POST만 지원
		
- ##### 주요 메소드 - POST
		전달한 데이터 처리/생성 요청 매서드(Create)

		메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버는 요청 데이터를 처리하여 업데이트

		전달된 데이터로 주로 신규 리소스 등록, 프로세스 처리에 사용

		만일 데이터를 GET하는데 있어, JSON으로 조회 데이터를 넘겨야하는 애매한 경우 POST를 사용
		
		비멱등성(여러번의 요청에 대해서 항상 동일한 결과x)의 특성 및 식별자르 보내지 않아야함
	- ###### JSON 데이터 전송 과정
		1. 클라이언트는 메시지 바디에 등록할 정보를 JSON형태로 만들어서 서버로 전송
		2. 서버에서는 해당 데이터를 처리 로직에 따라서 처리
		3. 처리 후 데이터를 바디에 담아서 클라이언트로 응답(신규 데이터 생성 시 201 또는 200 status로 반환)

	- ###### HTML Form 데이터 전송 과정
		1. 웹 문서에서 폼 입력칸에 데이터를 적고 전송
		2. 지정한 POST 메소드 동작에 따라 input 태그 안에 들어간 값들이 쿼리스트링으로 서버로 전송
		- HTML Form 태그 문서로 사용자와 UI로 상호작용하여 서버와 통신
		- 회원가입, 상품 주문, 데이터 변경 등등에 이용
		- HTML Form 전송은 GET, POST만 지원
	
	- ###### Content-Type 헤더 종류(enctype)
		- application/x-www-form-urlencoded
			- Form의 내용을 HTTP 메시지 바디를 통해서 전송(key=value, 쿼리 파라미터 형식)
			- 전송 데이터를 url encoding 처리
			- 예시 : abc김 -> abc%EA%B9%80

		- multipart/form-data
			- 파일 업로드 같은 바이너리 데이터 전송 시 사용
			- 다른 종류의 여러 파일과 Form의 내용 함께 전송 가능

		- application/json
			- TEXT, XML, JSON 데이터 전송 시 사용
		
		
	- ###### 파일 데이터 전송 과정
		- enctype을 *multipart/form-data* 로 작성 해 해당 폼에 파일이 있다는 것을 표시
		- 바이너리 데이터 전송 시 사용
		- *multipart/form-data* 형식이라면 HTTP 메시지에 임의의 구분자(---------XXX)가 Form 데이터 간 구분을 지어줌
		- 여러 개의 Content-Type에 대한 데이터를 보낼 수 있음

- ##### 주요 메소드 - PUT
		리소스를 수정하는 메소드(Update)

		만일 요청 메시지에 리소스가 있으면 덮어쓰고 없으면 새로 생성
		
		데이터를 대체(update)해야하니 리소스의 구체적인 경로를 지정해줘야 함

		멱등성(여러번의 요청에 대해서 항상 동일한 결과)를 가지고 있으며 식별자를 요청url에 포함

	- ###### PUT 요청에 리소스가 있는 경우
		1. 식별자를 통해 리소스를 교체한다는 요청
		2. 기존 데이터가 있을 경우, 완전하게 대체

	- ###### PUT 요청에 리소스가 없는 경우
		1. 식별자를 통해 리소스를 교체한다는 요청
		2. 기존 데이터가 없다면, POST처럼 신규로 생성

	- ###### PUT 요청에 일부 리소스만 변경하길 원하는 경우
		1. 식별자를 통해 리소스를 교체한다는 요청
		2. 기존 데이터가 있는데, 전체 리소스 중 일부 리소스만 남아있고 나머지 리소스는 데이터가 삭제

- ##### 주요 메소드 - PATCH
		리소스 일부 부분을 변경하는 메소드(Update)
		
		만일 PATCH를 지원하지 않는 서버에서는 대신에 POST를 사용
	1. 일부 리소스만 변경하려고 PATCH로 해당 데이터 전달

	2. PUT과는 다르게 일부 데이터만 변경

- ##### 주요 메소드 - DELETE
		리소스 제거하는 메소드(Delete)

		상태코드는 대부분 200을 사용하고 상황에 따라 204를 사용

		식별자를 통해서 해당 리소스를 특정
	
	1. 식별자를 통해 제거하고자 하는 리소스를 특정해서 Delete로 전달

	2.  서버에서 요청을 받고 데이터베이스의 해당 리소스를 제거

- ##### 기타 메소드 - HEAD
		GET과 동일하지만 서버에서 바디를 리턴하지 않음
		
		응답 상태 코드만 확인할 때와 같이 리소스를 받지 않고 오직 찾기만 원할 때 사용 (일종의 검사 용도)

		서버의 응답 헤더를 봄으로써 리소스가 수정 되었는지 확인 가능

    
- ##### 기타 메소드 - OPTIONS
		예비 요청에 사용되는 HTTP 메소드

		예비 요청이란 본 요청을 하기 전에 안전한지 미리 검사하는 것

		서버의 지원 가능한 HTTP 메소드와 출처를 응답받아 CORS정책을 검사하기 위한 요청

	- ###### CORS 정책
		- CORS(Cross-Origin Resource Sharing)는 다른 출처의 리소스에 접근할 수 있도록 하는 정책
		- 출처가 다른 서버와 안전하게 통신하기 위함
		- 출처 = 프로토콜 + 호스트 + 포트 (예: http://example:3000)
		
- ##### 기타 메소드 - CONNECT
		클라이언트가 서버와의 터널을 설정해 두 지점 간의 TCP 연결을 확립하기 위해서 사용

		HTTPS 요청을 위한 프록시 서버를 설정 

- ##### 기타 메소드 - TRACE
		일종의 검사용

		서버에 도달했을 때 최종 패킷의 요청 패킷 내용을 응답 받을 수 있음

		디버깅을 위해 사용하는 목적으로, 방화벽 및 프록시서버, 게이트웨이 등을 거쳐서 변조된 내용이 무엇인지 확인하려는 목적이나 이는 보안 취약점이 될 수 있어서 지양되는 메소드

## [HTTP STATUS](https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/)

|종류|내용|의미|
|:----:|:----:|:----|
|[1xx](#1xx)|Informational(정보 제공)|임시 응답으로 현재 클라이언트의 요청까지는 처리 되었으니 계속 진행하라는 의미| 
|[2xx](#2xx)|Success(성공)|클라이언트의 요청이 서버에서 성공적으로 처리 되었다는 의미| 
|[3xx](#3xx)|Redirection(리다이렉션)|완전한 처리를 위해 추가 동작이 필요한 경우로 해당 주소로 다시 시도하거나 연결해주는 의미| 
|[4xx](#4xx)|Client Error(클라이언트 에러)|없는 페이지를 요청하는 등 클라이언트 요청 메시지 내용이 잘못된 경우를 의미| 
|[5xx](#5xx)|Server Error(서버 에러)|서버에서 메시지 처리에 문제가 발생한 경우로, 서버의 부하, DB오류 등이 발생하는 경우를 의미| 

### 1XX
|종류|상태 텍스트|의미|
|:----|:----|:----|
|100|Continue|계속 진행하라는 의미| 
|101|Switching Protocols|프로토콜을 전환(업그레이드)| 
|102|Processing|타임아웃이 발생하지 않도록 처리중이라는 의미| 


### 2XX
|종류|상태 텍스트|의미|
|:----|:----|:----|
|200|OK|서버에서 요청을 성공적으로 처리| 
|201|Create|서버에서 요청이 처리되어서 새로운 리소스가 생성됨| 
|202|Accepted|요청은 접수하였지만 아직 처리가 완료되지 않음| 
|204|No Content|처리를 성공하였지만 클라이언트에게 돌려줄 컨텐츠가 없음|



### 3XX
|종류|상태 텍스트|의미|
|:----|:----|:----|
|301|Moved Permanently|지정한 리소스가 새로운 URI로 이동| 
|303|See Other|다른 위치로 요청하라는 의미| 
|304|Not Modified|마지막 요청 이후 요청 페이지가 수정되지 않음|
|307|Temporary Redirect|임시로 리다이렉션 요청이 필요함| 

### 4XX
|종류|상태 텍스트|의미|
|:----|:----|:----|
|400|Bad Request|잘못된 요청구문| 
|401|Unauthorized|지정한 리소스에 대한 액세스 권한이 없음| 
|403|Forbidden|지정한 리소스에 대한 액세스가 금지 됨| 
|404|Not Found|지정한 리소스를 찾을 수 없음|

### 5XX
|종류|상태 텍스트|의미|
|:----|:----|:----|
|500|Internal Server Error|서버에 에러가 발생| 
|501|Not Implemented|요청한 URI의 메소드에 대해 서버가 구현하고 있지 않음| 
|502|Bad Gateway|게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받음| 
|504|Gateway Timeout|게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 타임아웃이 발생|

## [HTTP HEADER](https://gmlwjd9405.github.io/2019/01/28/http-header-types.html)

### 항목
- [HTTP 헤더 내 일반 헤더(General Header)](#http-일반-헤더--요청-및-응답-메시지-모두에서-사용-가능한-일본-목적의-헤더)
- [HTTP 헤더 내 엔티디/개체 해더(Entity Header)](#http-엔티티-헤더--요청-및-응답-메시지-모두에서-사용-가능한-entity콘텐츠-본문-리소스에-대한-설명-헤더-항목)
- [HTTP 헤더 내 요청 해더(Request Header)](#http-요청-헤더--요청-메시지-내에서만-나타나며-가장-방대함)
- [HTTP 헤더 내 응답 헤더(Response Header)](#http-응답-헤더--http요청이나-헤더를-수신했을-때의-응답)
- [HTTP 헤더 내 캐시/쿠키 헤더](#http-캐시쿠키-헤더)

#### HTTP 일반 헤더 : 요청 및 응답 메시지 모두에서 사용 가능한 일본 목적의 헤더
- 주요 항목
	- Date : HTTP 메시지를 생성한 일시
	- Connnection : 클라이언트와 서버 간 연결에 대한 옵션 설정
	- Cache-Control
	- Pragma
	- Trailer

#### HTTP 엔티티 헤더 : 요청 및 응답 메시지 모두에서 사용 가능한 Entity(콘텐츠, 본문, 리소스)에 대한 설명 헤더 항목
- 주요 항목
	- Content-Type : 해당 개체에 포함되는 미디어 타입 정보
	- Content-Language : 해당 개체에 어울리는 사용자 언어
	- Content-Encoding : 해당 개체 데이터의 압축 방식
	- Content-Length : 해당 개체의 바이트 길이 또는 크기
	- Content-Location : 해당 개체의 실제 위치
	- Content-Disposition : 응답 바디를 브라우저가 표시하는 방법
	- Content-Security-Policy : 다른 외부 파일들을 불러오는 경우, 보완 관련 소스 명시
	- Location : 리다이렉트가 되었을 경우, 이동된 주소 또는 새로 생성된 리소스 주소 명시
	- Last-Modified : 리소스를 마지막으로 갱신한 일시
	- Transfer-Encoding : 바디가 길거나 길이를 모를경우 이를 청크로 나눠서 일부분씩 전송

#### HTTP 요청 헤더 : 요청 메시지 내에서만 나타나며 가장 방대함
- 주요 항목
	- Host : 요청하는 호스트에 대한 호스트명 및 포트 번호
	- User-Agent : 클라이언트 소프트웨어 명칭 및 버전 정보
	- From : 클라이언트 사용자 메일 주소
	- Cookie : 서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보
	- Referer : 바로 직전에 머물렀던 웹 링크 주소
	- If-Modified-Since : 제시한 일시 이후로만 변경된 리소스를 취득 요청
	- Authorization : 인증토큰을 서버로 보낼 때 사용하는 헤더
	- Origin : 서버로 POST요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타냄
	- Accept : 클라이언트 자신이 원하는 미디어 타입 및 우선순위
	- Accept-Charset : 문자 집합
	- Accept-Encoding : 문자 인코딩 방식
	- Accept-Language : 문자 언어

#### HTTP 응답 헤더 : HTTP요청이나 헤더를 수신했을 때의 응답
- 주요 항목
	- Server : 서버 소프트웨어 정보
	- Accept-Range
	- Set-Cookie : 서버측에서 클라이언트에게 세션 쿠기 정보를 설정
	- Expires : 리소스의 유효기간
	- Age : max-age 시간 내에서 시간이 얼마나 흘렀는지 초단위로 알려주는 캐시 응답
	- ETag : HTTP 컨텐츠가 바뀌었는지를 검사할 수 있는 태그
	- Proxy-authenticate
	- Allow : 서버측에서 지원 가능한 HTTP메소드의 리스트
	- Access-Control-Allow-Origin : CORS정책에 맞는 요청을 보내는 프론트의 주소

#### HTTP 캐시/쿠키 헤더
- 캐싱 관련
	- Cache-Control -> no-store : 아무것도 캐싱하지 않음
	- Cache-Control -> no-cache : 모든 캐시를 쓰기 전에 서버에 해당 캐시를 사용해도 되는지 확인
	- Cache-Control -> must-revalidate : 만료된 캐시만 서버에 확인
	- Cache-Control -> public : 공유 캐시에 저장해도 됨
	- Cache-Control -> private : 특정 사용자 환경에만 저장
	- Cache-Control -> max-age : 캐시의 유효기간
	- Expires : 캐시의 만료기간 (단, Cache-Control의 max-age가 있는경우 무시됨)
	- Age : max-age 시간 내에서 시간이 얼마나 흘렀는지 초단위로 알려주는 캐시 응답
	- ETag : HTTP 컨텐츠가 바뀌었는지를 검사할 수 있는 태그
	- If-None-Match : 서버에 ETag가 달라졌는지 검사 요청
- 쿠키 관련
	- Cookie : 서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보
	- Set-Cookie : 서버측에서 클라이언트에게 세션 쿠키 정보를 설정할 때 사용하는 항목


## REST API
- ### [REST(Representational State Transfer)](https://ko.wikipedia.org/wiki/REST)
		네트워크 아키텍쳐 원리의 모음

		웹 상의 자료를 HTTP위에서 별도의 전송 계층없이 전송하기 위한 인터페이스

		CRUD(Create, Read, Update, Delete)를 따라감
		
	- REST의 특징

		1. 인터페이스 일관성 : 일관적인 인터페이스로 분리 되어야 함

		2. 무상태 : 서버가 데이터를 들고 있지 않으며, 클라이언트는 서버에 요청을 보낼 때 모든 데이터를 들고 있어야 함

		3. 캐시 처리 기능 : 캐싱이 가능한 응답이여야하며, 이를 통해 서버의 과부화와 트래픽을 감소시킬 수 있음

		4. 계층화 : 보안, 로드 밸런싱, 프록시 등을 추가해 시스템 확장성, 보안성을 증가시키고 클라이언트는 중간계층을 알 필요가 없으며 API가 제공하는 데이터와 기능에 접근

		5. 클라이언트/서버 구조 : 클라이언트는 사용자 인터페이스, 서버는 데이터관리와 로직을 설계함으로 서로가 독립적으로 설계

- ### REST API
		REST의 특징을 기반으로 만든 API

	- REST API 설계 규칙
		1. 자원 명사는 복수형으로 사용
		2. HTTP 메소드는 목적에 맞게 사용
		3. 계층 구조를 이용한 URI설계
		4. 쿼리 파라미터로 정렬, 페이징 필터링 지원
		5. 응답에 HTTP Status 사용
		6. 일관된 데이터 형식 사용

- ### RESTful API
		REST원리를 따르는 시스템을 RESTful이라고 하며, REST API를 제공하면 이것이 RESTful API라고 함
	- 목적 : 이해하기 쉽고 사용하기 쉬운 REST API를 만들기 위함
	- RESTful하지 못한 경우
		- CRUD를 따르지 않고, 업데이트나 생성에 모두 POST를 사용하고, 데이터 조회시에도 POST를 사용하는 등 원래의 목적을 벗어난 API를 사용할 때 
		- 쿼리 스트링에 잘못된 정보나 불필요한 정보를 포함해서 API를 보내거나 URI가 설정될 때

## Cookie && Session
- ### [Cookie](https://ko.wikipedia.org/wiki/HTTP_%EC%BF%A0%ED%82%A4)
		사용자의 컴퓨터에 저장되는 이름을 가진 작은 크기의 데이터

		즉, 사용자가 어떤 웹사이트에 방문했을 경우 남는 작은 기록 정보파일
	- 쿠키의 구조
		1. 이름
		2. 값
		3. 0개 이상의 속성(key : value 구조)
			- 속성 : 쿠키의 만료기간, 도메인, 플래그 등
	- 쿠키의 목적
		1. 세션 관리 : 서버에 저장해야할 로그인, 장바구니 등의 정보 관리
		2. 개인화 : 사용자 테마 등 개인의 세팅
		3. 트래킹 : 사용자의 행동을 기록하고 분석하는 용도
	- 쿠키의 생성 방법
		- HTTP 요청을 수신할 떄, 서버에서 응답과 함께 Set-Cookie 헤더를 전송함으로 쿠키를 생성
		- 예시 : Set-Cookie: id=a3fWb; Expires=Wed, 21 Oct 2024 17:28:00 GMT;
	- 쿠키의 보안 관련 주의
		1. Secure 속성 : HTTPS 프로토콜 상에서 암호화된 요청일 경우에만 전송, 민감한 정보는 쿠키에 저장되면 안됨
		2. HTTP Only 속성 : XSS공격을 방지하기 위해서 자바스크립트에서 쿠키에 접근할 수 없도록 막음
		3. SameSite 속성 : 쿠키가 cross-site 요청과 함께 전송되지 않았음을 요구하게 만들어 cross-site요청 위조 공격(CSRF)를 방지
	
- ### [Session](https://developer.mozilla.org/ko/docs/Web/HTTP/Session)
		사용자가 웹 서버와 상호작용 하는동안 유지되는 상태

		사용자의 로그인상태, 장바구니 등 의 내용을 담아두는것

	- 세션의 특징 및 역할
		- 기본적으로 HTTP에서 무상태를 유지하기 때문에, 상태성을 유지해야하는 것들을 세션에서 관리함
		- 고유 ID를 통해서 관리하며 고유 ID는 쿠키로 저장이 됨
	
	- 세션의 작동 원리
		1. 사용자가 웹 사이트에 접속
		2. 세션 ID 저장
		3. 서버에서 세션 데이터 관리
		4. 사용자가 세션을 통해 상태 유지
		5. 세션 종료
	- 세션의 장점
		1. 상태 유지 : HTTP에서 무상태를 유지하는데, 이를 상태를 유지함으로 로그인 등 편리함 제공
		2. 보안 : 세션 데이터가 서버에 저장되므로 쿠키에 중요한 정보를 담을 필요가 없음
		3. 다양한 데이터 저장 가능 : 서버에 데이터가 저장되므로 클라이언트의 저장용량과 상관없이 데이터를 저장할 수 있음
	- 세션의 단점
		1. 서버 자원 사용 : 서버가 세션 관리를 하기때문에 사용자가 많아질 경우 서버에 부하가 걸림
		2. 서버 확장성 : 서버에 저장을 할 경우, 서버 확장 시 세션 데이터를 공유하는데 작업이 필요함
		

## [JWT]()

## [MVC && MVC2]()

## HTTPS & DNS Server & CI/CD
- ### [HTTPS]()
	-
- ### [DNS Server]()
	-
- ### [CI/CD]()
	-